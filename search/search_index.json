{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Homepage","text":"<p>Welcome! You don't need to create a project from scratch for this workshop. Instead, we'll work with a sample repository from the updated NSO Sandbox.</p> <p>In this project, you'll discover the real benefits of NetDevOps by exploring open-source testing and automation tools. You'll build your own setup and see how implementing CI/CD concepts can improve the quality and reliability of deployments through thorough testing and version control.</p>"},{"location":"#section-1-introduction-to-cicd-automation-and-nso-verification","title":"Section 1: Introduction to CI/CD, Automation, and NSO Verification","text":"<p>In this section, we'll introduce key concepts such as Continuous Integration and Continuous Deployment (CI/CD), automation, and the basics of NSO (Network Services Orchestrator). We'll also discuss source version control, focusing on GitLab.</p>"},{"location":"#section-2-cicd-pipelines-with-nso","title":"Section 2: CI/CD Pipelines with NSO","text":"<p>Here, we'll dive into the concept of a CI/CD pipeline. You'll learn how to create, execute, and trigger automated processes, and see how CI/CD pipelines can be used for developing and deploying NSO service packages.</p>"},{"location":"#section-3-automated-testing","title":"Section 3: Automated Testing","text":"<p>This section covers the role of automated testing within the CI/CD pipeline. We'll demonstrate how to implement automated tests for NSO service packages using Robot Framework and basic pre-commit checks, ensuring they meet requirements and function correctly before deployment.</p>"},{"location":"#lab-topology","title":"Lab Topology","text":"<p>Here's a brief overview of the dCloud setup used in this lab:</p> <ul> <li>Access: Connect using Cisco Secure Client VPN. Details are provided on the access page.</li> <li>Network Setup: Two Cisco Modeling Labs (CML) environments are available\u2014one simulates the live network, and the other is for testing.</li> <li>Production NSO: The main NSO deployment manages network devices within the CML.</li> <li>Developer Workstation (DevBox): A Linux VM for developing new services, running tests, and initiating pipelines.</li> <li>Developer Tools (DevTools): Another Linux VM equipped with various tools needed for lab activities.</li> <li>NSO Instances: Two NSO 6.4.4 instances serve as development and production environments.</li> </ul> <p></p>"},{"location":"Conclusion/","title":"Conclusion","text":"<p>In this demo, we explored how NSO can be integrated into a CI/CD pipeline to manage network services efficiently.</p> <ul> <li>We began by updating the pipeline configuration and pushing changes to trigger automated testing and validation of the NSO service under development.</li> <li>Once we confirmed that our service behaved as expected, we merged the changes from our testing branch into the main branch.</li> <li>This merge triggered an automatic deployment of the service to the NSO production environment, demonstrating a seamless transition from development to production.</li> <li>To improve visibility and reduce semantic and syntactical errors, we incorporated Robot Framework tests, lint checks, and pyATS validation.</li> </ul> <p>This process demonstrates the complete lifecycle of developing, testing, and deploying network service changes within a CI/CD framework, ensuring both reliability and efficiency in managing network infrastructure.</p> <p>We hope you now feel comfortable with the role these tools play in modern network automation and CI/CD workflows. Thank you for participating!</p>"},{"location":"lab_guides/connectivity/Access/","title":"Workshop Access &amp; Login","text":""},{"location":"lab_guides/connectivity/Access/#verification","title":"Verification","text":"<ul> <li>Access GitLab: All the bookmarks for this sessions are available in Google Chrome, select DEVWKS-2618 Bookmark folder and Web IDE. (You can also  navigate to http://devtools-gitlab.lab.devnetsandbox.local to access the GitLab UI.) Log in with username <code>developer</code> and password <code>C1sco12345</code>.</li> </ul>"},{"location":"lab_guides/connectivity/Access/#examine-nso-deployment","title":"Examine NSO Deployment","text":"<p>In the Sandbox, there are three different instances of Cisco Network Services Orchestrator (NSO). These instances have been pre-provisioned with the necessary Network Element Drivers (NEDs) and configured to manage the devices in the lab topology.</p> <p>For the purpose of this workshop, we will focus on two specific NSO environments:</p> <p>Development NSO: <code>10.10.20.47</code></p> <p>Production NSO: <code>10.10.20.48</code></p> <p>The Development NSO environment (<code>10.10.20.47</code>) is used to simulate a testing environment where we can validate our changes before deploying them to the production environment. This ensures that any modifications are thoroughly tested and verified, reducing the risk of issues in the Production NSO environment (<code>10.10.20.48</code>).</p>"},{"location":"lab_guides/connectivity/Access/#log-into-nso","title":"Log into NSO","text":"<p>Launch an SSH session to the Dev NSO instance (<code>10.10.20.47</code>) and log in using username <code>developer</code> and password <code>C1sco12345</code>.</p> Click here to show solution <pre><code>ssh developer@10.10.20.47\n</code></pre>"},{"location":"lab_guides/connectivity/Access/#access-the-nso-shell","title":"Access the NSO shell","text":"<p>Use the <code>ncs_cli</code> command to access the NSO command shell. The command prompt will change to <code>admin@ncs#</code>.</p> Click here to show solution <pre><code>ncs_cli -Cu admin\n</code></pre>"},{"location":"lab_guides/connectivity/Access/#display-the-devices","title":"Display the devices","text":"<p>The <code>show devices</code> command displays the devices in the sandbox topology that were provisioned in NSO during lab setup. We will be working with the Core and Distribution routers in this workshop. However, you can experiment with the other devices if you want.</p> Click here to show solution <pre><code>show devices list\n</code></pre> <p>Expected output: <pre><code>NAME             ADDRESS       DESCRIPTION  NED ID\n----------------------------------------------------------------\ncore-rtr01       10.10.20.173  -            cisco-iosxr-cli-7.65\ndev-core-rtr01   10.10.20.174  -            cisco-iosxr-cli-7.65\ndev-dist-rtr01   10.10.20.176  -            cisco-ios-cli-6.109\ndev-dist-sw01    10.10.20.178  -            cisco-nx-cli-5.27\ndist-rtr01       10.10.20.175  -            cisco-ios-cli-6.109\ndist-sw01        10.10.20.177  -            cisco-nx-cli-5.27\nedge-firewall01  10.10.20.171  -            cisco-asa-cli-6.18\nedge-sw01        10.10.20.172  -            cisco-ios-cli-6.109\ninternet-rtr01   10.10.20.181  -            cisco-ios-cli-6.109\n</code></pre></p>"},{"location":"lab_guides/connectivity/Access/#view-devices-in-the-nso-gui","title":"View devices in the NSO GUI","text":"<p>Select the NSO bookmark in Google Chrome or navigate to http://10.10.20.47:8080/ Log in using the username <code>developer</code> and password <code>C1sco12345</code>.</p> <ol> <li>Navigate to the Device Manager tab to view the devices.</li> <li>Ensure all devices are operational and correctly onboarded to NSO: select each device and run the Connect action.</li> </ol> <p></p> <p>If all steps are executed correctly, you will have completed the verification of your working environment.</p>"},{"location":"lab_guides/connectivity/Connectivity/","title":"Getting Started - Connectivity &amp; Access","text":"<p>This workshop is going to be focused on the NSO Reservable Sandbox which received a recent update to upgrade the tools (Gitlab, Robot framework etc..) and a HA build for NSO (6.4.4)</p> <p>Connectivity to the lab will be via Cisco Secure Client to an instance specific to your seat number. You can find the below credentials to connect and an example entry below:</p>"},{"location":"lab_guides/connectivity/Connectivity/#vpn-connectivity","title":"VPN Connectivity","text":"<p>You can find the credentials to connect to the VPN for your seat below. You will need to use the Cisco Secure Client (formerly AnyConnect) to connect to the VPN. If you do not have it installed, you can download it from the Cisco Software Download page.</p> <p>The VPN Username is provided in the presentation and the VPN Password is provided in the table below. The VPN Address is the same for all seats, but the port number will be different for each seat.</p>"},{"location":"lab_guides/connectivity/Connectivity/#vpn-credentials","title":"VPN Credentials","text":"Pod Name VPN Address VPN Password primary https://devnetsandbox-usw1-reservation.cisco.com:20293 J&amp;Xn9TAxT%52GKa5 seat1 https://devnetsandbox-usw1-reservation.cisco.com:20436 LbdM0!O6xE4&amp;hMe seat2 https://devnetsandbox-usw1-reservation.cisco.com:20437 Q8A&amp;TO8Hq3*kkdAT seat3 https://devnetsandbox-usw1-reservation.cisco.com:20438 86iDV%RNZ$u8ofn seat4 https://devnetsandbox-usw1-reservation.cisco.com:20320 kVa06_nPCc4^O seat5 https://devnetsandbox-usw1-reservation.cisco.com:20439 K#5WL3Gp7%uip seat6 https://devnetsandbox-usw1-reservation.cisco.com:20406 6Tt3gAQj%p^1 seat7 https://devnetsandbox-usw1-reservation.cisco.com:20442 '&amp;0VXp9jHp3mEO%' seat8 https://devnetsandbox-usw1-reservation.cisco.com:20443 41Za$9tI#oy2Nd seat9 https://devnetsandbox-usw1-reservation.cisco.com:20444 3Wa%Ml&amp;4&amp;fF9 seat10 https://devnetsandbox-usw1-reservation.cisco.com:20445 63^C^qLn0ElZ seat11 https://devnetsandbox-usw1-reservation.cisco.com:20441 ^rvZ43MzXA%E99$T seat12 https://devnetsandbox-usw1-reservation.cisco.com:20448 8QdvUH&amp;0QT#x7IWh seat13 https://devnetsandbox-usw1-reservation.cisco.com:20449 vuP0#rl!O&amp;6K6 seat14 https://devnetsandbox-usw1-reservation.cisco.com:20450 Abj1p9U^8uZzT# seat15 https://devnetsandbox-usw1-reservation.cisco.com:20451 P&amp;K2w%3cPugW%Xo1 seat16 https://devnetsandbox-usw1-reservation.cisco.com:20452 XZoB687H**tKsx speaker1 https://devnetsandbox-usw1-reservation.cisco.com:20327 b0rqm8%SBQYm1*h% speaker2 https://devnetsandbox-usw1-reservation.cisco.com:20430 PRn47&amp;mR8J_!*7u"},{"location":"lab_guides/pipeline/Deploy_Pipeline/","title":"Pipeline-Driven NSO Service Development","text":"<p>After understanding the concept of a pipeline and its stages, we'll move on to modifying the NSO package service in the <code>nso_cicd/packages/loopback</code> directory. Our GitLab CI/CD pipeline will automate the verification process by compiling the package and performing a compatibility (smoke) test with the current NSO version.</p> <p>The pipeline will also automate the deployment of the package service in the NSO development environment and run tests using Python and PyATS. Once all pipeline stages complete successfully, you can confidently deploy the changes to the production environment.</p>"},{"location":"lab_guides/pipeline/Deploy_Pipeline/#task-3-create-a-test-branch","title":"Task 3: Create a Test Branch","text":"Reminder: What is a branch? <p>In Git, a branch is a lightweight, movable pointer to a commit. Branches allow you to create separate lines of development within a repository, enabling you to work on different features, bug fixes, or experiments simultaneously without affecting the main codebase. Branches are central to most version control workflows, making parallel development and collaboration easy. Developers can experiment and innovate without disrupting stable code.</p> <p>Key Concepts: - Default Branch: The main line of development, usually called <code>main</code> or <code>master</code>.</p> <ul> <li> <p>Feature Development: Create new branches for each feature, bug fix, or task. This isolates changes from the main branch until they're ready to be merged.</p> </li> <li> <p>Branch Creation: Use <code>git branch</code> or <code>git checkout -b</code> to create and switch to a new branch.</p> </li> <li> <p>Switching Branches: Use <code>git checkout</code> to switch between branches.</p> </li> <li> <p>Merging: Once work is complete and tested, merge the branch back into another branch (typically <code>main</code>) using <code>git merge</code>.</p> </li> <li> <p>Collaboration: Multiple developers can work on their own branches and merge changes into shared branches as needed.</p> </li> </ul> <p>Creating a test branch allows you to make changes safely without impacting the production NSO service package stored in the main branch. By committing and pushing changes to this test branch in GitLab, the pipeline will automatically compile, test, and deploy the NSO package to the development environment and execute the test scripts. You can then review the pipeline's pass/fail status to ensure your changes are successful.</p> <p></p> <p>You should now have a new branch called <code>package_dev_demo</code> and be working on that branch.</p>"},{"location":"lab_guides/pipeline/Deploy_Pipeline/#task-4-update-the-nso-loopback-template","title":"Task 4: Update the NSO Loopback Template","text":"Reminder: What is a template, and how is it different from a model? <p>YANG models and templates together enable full lifecycle management of network services\u2014from design and deployment to monitoring and troubleshooting. This combination allows network operators to define services once and deploy them consistently across diverse network environments, scaling operations efficiently. YANG models and templates are integral to NSO's automation capabilities, allowing for rapid deployment and modification of network services, and reducing the need for manual intervention.</p> <p>Key Concepts: - Configuration Generation: Templates in NSO generate device-specific configuration snippets from the abstract service definitions provided by YANG models.</p> <ul> <li> <p>Device-Specific Customization: While YANG models define the abstract structure, templates handle the nuances of various device types and vendors, allowing NSO to push the correct configurations to different devices.</p> </li> <li> <p>Separation of Concerns: Templates separate service logic from device-specific syntax, making maintenance and updates easier.</p> </li> <li> <p>Reusable Components: Templates can be reused across different services, promoting consistency and reducing duplication.</p> </li> </ul> <p>To complete the development of the Loopback service and ensure all tests pass, modify the file <code>loopback-template.xml</code> located in <code>/nso_cicd/packages/loopback/templates</code>. Include the XML configurations as specified below, making sure they match exactly:</p> <p>Question: Why do we need to define different interface templates for IOS and IOS XR?</p> <pre><code>&lt;config-template xmlns=\"http://tail-f.com/ns/config/1.0\"\n                 servicepoint=\"loopback\"&gt;  \n  &lt;devices xmlns=\"http://tail-f.com/ns/ncs\"&gt;  \n    &lt;!-- DEVICE --&gt;\n    &lt;device&gt;  \n      &lt;name&gt;{/device}&lt;/name&gt;  \n      &lt;config&gt;  \n        &lt;!-- IOS --&gt;\n        &lt;interface xmlns=\"urn:ios\"&gt; \n          &lt;Loopback&gt; \n            &lt;name&gt;{/loopback-intf}&lt;/name&gt;\n            &lt;ip&gt; \n              &lt;address&gt; \n                &lt;primary&gt; \n                  &lt;address&gt;{/ip-address}&lt;/address&gt;\n                  &lt;mask&gt;255.255.255.255&lt;/mask&gt; \n                &lt;/primary&gt; \n              &lt;/address&gt; \n            &lt;/ip&gt; \n          &lt;/Loopback&gt; \n        &lt;/interface&gt; \n        &lt;!-- IOS-XR --&gt;\n        &lt;interface xmlns=\"http://tail-f.com/ned/cisco-ios-xr\"&gt; \n          &lt;Loopback&gt; \n            &lt;id&gt;{/loopback-intf}&lt;/id&gt;\n            &lt;ipv4&gt; \n              &lt;address&gt; \n                &lt;ip&gt;{/ip-address}&lt;/ip&gt;\n                &lt;mask&gt;255.255.255.255&lt;/mask&gt; \n              &lt;/address&gt; \n            &lt;/ipv4&gt; \n          &lt;/Loopback&gt; \n        &lt;/interface&gt;  \n      &lt;/config&gt; \n    &lt;/device&gt; \n  &lt;/devices&gt; \n&lt;/config-template&gt;\n</code></pre>"},{"location":"lab_guides/pipeline/Deploy_Pipeline/#task-5-update-the-gitlab-pipeline","title":"Task 5: Update the GitLab Pipeline","text":"<p>Now it's time to make our pipeline actually do something! For this workshop, we'll use a pipeline to package an NSO loopback service, perform validation, and apply the service to a device.</p> <p>To enhance practicality and efficiency, you can replace your CI file with the pipeline below and commit the changes. Don't worry too much about the details of each task; if we have time at the end, we can revisit the functions.</p> <p>Question: Which stages will run when making changes in our test pipeline?</p> Gitlab runner .gitlab-ci.yml<pre><code>include:\n  - '/nso_cicd/pipeline_utils/environments.yml'\n\n# Define the stages of the pipeline\nstages:\n  - build\n  - test\n  - deliver\n  - deploy_prod\n\nrunner pre-reqs:\n  stage: .pre\n  when: on_success\n  script:\n    - echo \"(Pre-reqs) Checking the environment\"\n    - python --version\n    - pipx install robotframework-sshlibrary --include-deps --force\n    - sshpass -p \"$NSO_DEV_PWD\" ssh -o StrictHostKeyChecking=no $NSO_DEV_USER@$NSO_DEV_IP \"echo 'NSO Dev Environment Accessible'\"\n    - sshpass -p \"$NSO_PROD_PWD\" ssh -o StrictHostKeyChecking=no $NSO_DEV_USER@$NSO_PROD_IP \"echo 'NSO Prod Environment Accessible'\"\n\n# Step to compile the package in the development NSO environment\npackage-compilation-\ud83d\udd28:\n  stage: build\n  when: on_success\n  except:\n    - main\n  script:\n    - echo \"(Build \ud83d\udd28) Loading and compiling packages in the NSO dev container\"\n    - sshpass -p \"$NSO_DEV_PWD\" scp -o StrictHostKeyChecking=no -r nso_cicd/packages/$PACKAGE $NSO_DEV_USER@$NSO_DEV_IP:/home/developer/$PACKAGE\n    - sshpass -p \"$NSO_DEV_PWD\" ssh -o StrictHostKeyChecking=no $NSO_DEV_USER@$NSO_DEV_IP \"\n        cd /home/developer/ &amp;&amp;\n        cp -r $PACKAGE /nso/run/packages &amp;&amp;\n        source /opt/ncs/ncs-6.4.4/ncsrc &amp;&amp;\n        cd /nso/run/packages/$PACKAGE/src &amp;&amp;\n        make clean &amp;&amp;\n        make &amp;&amp;\n        cd /nso/run/packages &amp;&amp;\n        tar -czvf /home/developer/nso-package_$PACKAGE.tar.gz $PACKAGE\"\n\n# Step to load the compiled package into the testing NSO environment\npackage-load-\ud83d\udce5:\n  stage: build\n  when: on_success\n  except:\n    - main\n  script:\n    - echo \"(Build \ud83d\udce5) Loading compiled packages to testing env NSO\"\n    # SSH into the NSO development environment and reload the package\n    - sshpass -p \"$NSO_DEV_PWD\" ssh -o StrictHostKeyChecking=no $NSO_DEV_USER@$NSO_DEV_IP \"\n      source /opt/ncs/ncs-6.4.4/ncsrc &amp;&amp;\n      echo 'packages reload' | ncs_cli -Cu admin\"\n  dependencies:\n    - package-compilation-\ud83d\udd28\n\n# Step to test the loopback service in the NSO testing environment\ntest-loopback-service-\ud83d\udd75\ud83c\udffd:\n  stage: test\n  when: on_success\n  except:\n    - main\n  script:\n    - echo \"(Test \ud83d\udd75\ud83c\udffd) Deploying service in the NSO test env\"\n    # Test the service on an IOS-XR device\n    - echo \"Test IOS-XR\"\n    - cd nso_cicd/tests/loopback-test &amp;&amp; python loopback-test.py --nso_url \"http://$NSO_DEV_IP:8080\" --device \"dev-core-rtr01\" --username $NSO_DEV_USER --password $NSO_DEV_PWD\n    # Test the service on an IOS device\n    - echo \"Test IOS\"\n    - python loopback-test.py --nso_url \"http://$NSO_DEV_IP:8080\" --device \"dev-dist-rtr01\" --username $NSO_DEV_USER --password $NSO_DEV_PWD\n  dependencies:\n    - package-load-\ud83d\udce5\n\n# Step to clean up the development environment\ncleanup-\ud83d\uddd1\ufe0f:\n  stage: .post\n  only:\n    - main\n  allow_failure: true\n  script:\n    - echo \"(Cleanup \ud83d\uddd1\ufe0f) Removing files from NSO Dev\"\n    # SSH into the NSO development environment and remove the package files\n    - sshpass -p \"$NSO_DEV_PWD\" ssh -o StrictHostKeyChecking=no $NSO_DEV_USER@$NSO_DEV_IP \"\n      rm -rf $PACKAGE &amp;&amp;\n      rm -rf cd /nso/run/packages/$PACKAGE &amp;&amp;\n      source /opt/ncs/ncs-6.4.4/ncsrc &amp;&amp; echo 'packages reload force' | ncs_cli -Cu admin\"\n\n# Step to load the package tarball onto the production NSO environment\nload-production-\ud83d\udce6:\n  stage: deploy_prod\n  when: on_success\n  only:\n    - main\n  script:\n    - echo \"(Load\ud83d\udce6) Copying tarball to production NSO.\"\n    - sshpass -p \"$NSO_DEV_PWD\" scp -o StrictHostKeyChecking=no $NSO_DEV_USER@$NSO_DEV_IP:/home/developer/nso-package_$PACKAGE.tar.gz .\n    - sshpass -p \"$NSO_PROD_PWD\" scp -o StrictHostKeyChecking=no nso-package_$PACKAGE.tar.gz $NSO_DEV_USER@$NSO_PROD_IP:/home/developer/\n\n# Step to deploy the package on the production NSO environment\ndeploy-production-\ud83d\udcec:\n  stage: deploy_prod\n  when: on_success\n  only:\n    - main\n  script:\n    - echo \"(Deploy\ud83d\udcec) Deploying package on production NSO.\"\n    - sshpass -p \"$NSO_PROD_PWD\" ssh -o StrictHostKeyChecking=no $NSO_DEV_USER@$NSO_PROD_IP \"\n        cd /home/developer/ &amp;&amp;\n        tar -xvf nso-package_$PACKAGE.tar.gz &amp;&amp;\n        rm -rf nso-package_$PACKAGE.tar.gz &amp;&amp;\n        cp -r $PACKAGE /nso/run/packages/loopback &amp;&amp;\n        source /opt/ncs/ncs-6.4.4/ncsrc &amp;&amp;\n        cd /nso/run/packages/$PACKAGE/src &amp;&amp;\n        make clean &amp;&amp;\n        make &amp;&amp;\n        echo 'packages reload' | ncs_cli -Cu admin\"\n  dependencies:\n    - load-production-\ud83d\udce6\n</code></pre> <p>Note: For more details on the pipeline configuration, see the GitLab documentation.</p> <p>Navigate to http://devtools-gitlab.lab.devnetsandbox.local/developer/nso_cicd/-/pipelines in your web browser to view the status of the pipeline.</p> <p>This process may take a few minutes to complete. While the stages are running, review the completed ones to see what is happening.</p> <p>What was the outcome of the testing phase?</p> <p>Is the loopback service available in the development NSO instance?</p> <p></p>"},{"location":"lab_guides/pipeline/Dummy_Pipeline/","title":"Define the CI/CD Pipeline","text":"REMINDER - What is a Pipeline? <p>The CI/CD pipeline is responsible for validating changes made to files in the GitLab repository, running automated tests, and deploying code to production if all validations and tests pass.</p> <p>In GitLab, a pipeline is defined using a YAML file, often named <code>.gitlab-ci.yml</code>. This file specifies the tasks to be executed as part of the pipeline, which are organized into stages such as <code>build</code>, <code>test</code>, and <code>deploy</code>, with specific task definitions for each stage.</p> <p>A pipeline can consist of various stages, each designed to perform specific actions, including: * Building and compiling code or packages * Deploying to a test environment * Executing test cases to validate functionality * Cleaning up development environments * Deploying to production environments</p> <p>These actions are executed by 'runners.' In the sandbox, a runner is automatically registered for all projects, with most of the tools you need. In this task, you'll follow a step-by-step process to create a pipeline tailored to your project.</p> <p>In this project repository, you will store your files and add a CI file that can be interpreted by GitLab. This file is the collection of stages and tasks that will make up your pipeline. Next, add your configuration template to the repository. Storing it centrally enables tracking of changes, collaborative work, and rollback of commits if needed. After your files are set, create the CI file called <code>.gitlab-ci.yml</code> to describe the procedure of your pipeline.</p>"},{"location":"lab_guides/pipeline/Dummy_Pipeline/#task-1-open-the-web-ide","title":"Task 1: Open the Web IDE","text":"<p>We'll use the Web IDE to make changes. Open up the Default Project and select the Web IDE from the Edit dropdown.</p> <p></p>"},{"location":"lab_guides/pipeline/Dummy_Pipeline/#task-2-create-a-new-gitlab-ci-file","title":"Task 2: Create a New GitLab CI File","text":"<p>Next, create the pipeline definition in the GitLab repository. This triggers an initial execution of the pipeline because you are adding the <code>.gitlab-ci.yml</code> file to the repo. No changes will be made to the network devices yet, as you have not made any changes to the definition files.</p> <p></p> <p>To save time, we've provided an example pipeline below. Copy and paste this into your new CI file:</p> Gitlab runner .gitlab-ci.yml<pre><code># Define the stages of the pipeline\nstages:\n  - build\n  - test\n  - deliver\n  - cleanup\n  - deploy_prod\n\n# Step to compile the package in the development NSO environment\npackage-compilation-\ud83d\udd28:\n  stage: build\n  script:\n    - echo \"Executing build stage - package-compilation-\ud83d\udd28\"\n\n# Step to load the compiled package into the testing NSO environment\npackage-load-\ud83d\udce5:\n  stage: build\n  script:\n    - echo \"Executing build stage - package-load-\ud83d\udce5\"\n\n# Step to test the loopback service in the NSO testing environment\ntest-loopback-service-\ud83d\udd75\ud83c\udffd:\n  stage: test\n  script:\n    - echo \"Executing test stage - test-loopback-service-\ud83d\udd75\ud83c\udffd\"\n\n# Step to generate and publish the release package\nrelease-publishing-\ud83d\udce6:\n  stage: deliver\n  script:\n    - echo \"Executing deliver stage - release-publishing-\ud83d\udce6\"\n\n# Step to clean up the development environment\ncleanup-\ud83d\uddd1\ufe0f:\n  stage: cleanup\n  script:\n    - echo \"Executing cleanup stage - cleanup-\ud83d\uddd1\ufe0f\"\n\n# Step to deploy the package to the production NSO environment\ndeploy-production-\ud83d\udcec:\n  stage: deploy_prod\n  script:\n    - echo \"Executing deploy_prod stage - deploy-production-\ud83d\udcec\"\n</code></pre> <p>Note: For more details on the pipeline configuration, see the GitLab documentation.</p> <p>Commit your changes to the main branch by selecting the Source Control icon on the left.</p>"},{"location":"lab_guides/pipeline/Dummy_Pipeline/#task-3-examine-the-pipeline-job","title":"Task 3: Examine the Pipeline Job","text":"<p>Navigate to http://devtools-gitlab.lab.devnetsandbox.local/developer/Default_Project/-/pipelines. The pipeline should pass, since no changes are being made. If you click on the \"passed\" indication in the Status column, you should see that only the <code>deploy_prod</code> stage executed. This is because the pipeline configuration in <code>.gitlab-ci.yml</code> has <code>except</code> clauses on the test stages for the main branch.</p> <p></p> <p>To verify that the script executed properly, open the job details.</p> <p></p> <p>To view detailed information about each stage, click on the <code>passed</code> button in the status column.</p> <p></p>"},{"location":"lab_guides/pipeline/apply/","title":"Applying Our Service","text":"<p>Now that we've added some basic tests, let's move straight into deploying our service!</p>"},{"location":"lab_guides/pipeline/apply/#task-6-apply-the-nso-service","title":"Task 6: Apply the NSO Service","text":"Reminder: RESTCONF <p>Cisco NSO uses RESTCONF to provide a standardized, RESTful API interface for interacting with network configurations and services.</p> <ul> <li> <p>RESTCONF is a RESTful protocol for accessing and manipulating network configuration data defined in YANG models.</p> </li> <li> <p>It provides a standardized HTTP-based interface for retrieving, configuring, and monitoring network settings.</p> </li> <li> <p>Utilizes standard HTTP methods (GET, POST, PUT, DELETE) for operations and supports JSON or XML for data representation.</p> </li> <li> <p>Aims to simplify network management with consistent interaction across diverse network elements.</p> </li> </ul> <p>Below is a basic Python script to apply the service to the device <code>dev-dist-rtr01</code>. Please create a file named <code>apply.py</code> within the <code>nso_cicd</code> directory and copy the following contents into it. This script authenticates with the NSO development instance and applies the loopback service with a statically defined address of <code>10.100.66.1</code>. (Note: In a real-world scenario, using a static address like this could cause conflicts!)</p> <pre><code>#!/usr/bin/env python\n# -*- coding:utf-8 -*-\n\nimport requests\nimport json\nimport argparse\nimport base64\n\n# Disable warnings for self-signed certificates\nrequests.packages.urllib3.disable_warnings()\n\n# Argument parser setup\nparser = argparse.ArgumentParser(description='NSO service management script')\nparser.add_argument('--nso_url', type=str, default='http://localhost:8080', help='NSO server URL')\nparser.add_argument('--device', type=str, default='ios-0', help='Device name')\nparser.add_argument('--username', type=str, default='developer', help='NSO username')\nparser.add_argument('--password', type=str, default='C1sco12345', help='NSO password')\nargs = parser.parse_args()\n\nNSO_URL = args.nso_url\nDEVICE_NAME = args.device\nUSERNAME = args.username\nPASSWORD = args.password\n\n# Encode username and password for the authorization header\nauth_str = f'{USERNAME}:{PASSWORD}'\nauth_bytes = auth_str.encode('ascii')\nauth_base64 = base64.b64encode(auth_bytes).decode('ascii')\n\nHEADERS = {\n    'Content-Type': 'application/yang-data+json',\n    'Authorization': f'Basic {auth_base64}',\n    'Accept': 'application/yang-data+json'\n}\n\n# Define the service payload\ndef apply_service():\n    payload = json.dumps({\n        \"loopback:loopback\": [\n            {\n                \"name\": \"loopback_service_1\",\n                \"device\": DEVICE_NAME,\n                \"loopback-intf\": 1166,\n                \"ip-address\": \"10.100.66.1\"\n            }\n        ]\n    })\n    url = f'{NSO_URL}/restconf/data/tailf-ncs:services/loopback:loopback'\n    response = requests.request(\"PATCH\", url, headers=HEADERS, data=payload)\n    if response.status_code in [200, 201, 204]:\n        print('Successfully applied service to device')\n        print(response.status_code)\n    else:\n        print(f'Failed to apply service: {response.status_code} {response.text}')\n\nif __name__ == \"__main__\":\n    apply_service()\n</code></pre>"},{"location":"lab_guides/pipeline/apply/#task-7-update-the-pipeline-to-apply-the-service","title":"Task 7: Update the Pipeline to Apply the Service","text":"<p>Next, let's add a task to the pipeline to apply the service to <code>dev-dist-rtr01</code>. Update your pipeline as shown below:</p> <pre><code>apply_service-\ud83d\udce6:\n  stage: deliver\n  when: on_success\n  script:\n    - echo \"Apply IOS\"\n    - python nso_cicd/apply.py --nso_url \"http://$NSO_DEV_IP:8080\" --device \"dev-dist-rtr01\" --username $NSO_DEV_USER --password $NSO_DEV_PWD\n</code></pre> <p>Has the configuration been applied to the device correctly?</p>"},{"location":"lab_guides/testing/compliance_reporting/","title":"Compliance Reporting","text":"<p>An important step in gaining acceptance of newly automated processes is providing visibility and assurance of their success. NSO Compliance Reporting is a feature within Cisco NSO that helps network operators assess and ensure that network device configurations adhere to predefined policies and standards. It enables automated auditing and reporting on compliance status across network elements, making it easier to identify and remediate configuration drift and inconsistencies in a timely manner.</p> <p>To get started, create a Python script in the <code>nso_cicd/</code> folder named <code>compliance.py</code> using the code provided below. Then, add the following line to your GitLab CI pipeline to execute the script after the apply script in the <code>apply_service</code> job.</p> <pre><code>#!/usr/bin/env python\n# -*- coding:utf-8 -*-\n\nimport requests\nimport base64\nimport os\nimport sys\nimport logging\nimport argparse\nfrom typing import Optional\n\n# Disable warnings for self-signed certificates\nrequests.packages.urllib3.disable_warnings()\n\nlogging.basicConfig(\n    level=logging.INFO,\n    format='[%(levelname)s] %(message)s'\n)\n\ndef create_compliance_report(nso_url: str, user: str, pwd: str, device: str = \"dev-dist-rtr01\", report_name: str = \"Loopback_report\") -&gt; Optional[requests.Response]:\n    url = f\"{nso_url}/restconf/data/tailf-ncs:compliance/\"\n    headers = {\n        'Content-Type': 'application/yang-data+xml',\n        'Accept': 'application/yang-data+json, application/yang-data+xml',\n    }\n    xml_data = f'''&lt;compliance xmlns=\"http://tail-f.com/ns/ncs\"&gt;\n    &lt;reports&gt;\n        &lt;report&gt;\n            &lt;name&gt;{report_name}&lt;/name&gt;\n            &lt;device-check&gt;\n                &lt;device&gt;{device}&lt;/device&gt;\n            &lt;/device-check&gt;\n            &lt;service-check&gt;\n                &lt;select-services&gt;/services/loopback:loopback&lt;/select-services&gt;\n                &lt;current-out-of-sync&gt;true&lt;/current-out-of-sync&gt;\n            &lt;/service-check&gt;\n        &lt;/report&gt;\n    &lt;/reports&gt;\n&lt;/compliance&gt;'''\n    try:\n        resp = requests.patch(\n            url,\n            headers=headers,\n            data=xml_data,\n            auth=(user, pwd),\n            verify=False,\n            timeout=15\n        )\n        if resp.ok:\n            logging.info(f\"[PATCH] Compliance report created: {resp.status_code}\")\n        else:\n            logging.error(f\"[PATCH] Failed to create compliance report: {resp.status_code}\\n{resp.text}\")\n            sys.exit(1)\n        return resp\n    except requests.RequestException as e:\n        logging.error(f\"[PATCH] Exception: {e}\")\n        sys.exit(1)\n\ndef run_compliance_report(nso_url: str, user: str, pwd: str, report_name: str = \"Loopback_report\", outformat: str = \"html\") -&gt; Optional[requests.Response]:\n    url = f\"{nso_url}/restconf/data/tailf-ncs:compliance/reports/report={report_name}/run\"\n    headers = {\n        'Content-Type': 'application/yang-data+xml',\n        'Accept': 'application/yang-data+json',\n    }\n    run_data = f'''&lt;input&gt;\\n    &lt;outformat&gt;{outformat}&lt;/outformat&gt;\\n&lt;/input&gt;'''\n    try:\n        resp = requests.post(\n            url,\n            headers=headers,\n            data=run_data,\n            auth=(user, pwd),\n            verify=False,\n            timeout=15\n        )\n        if resp.ok:\n            logging.info(f\"[POST] Compliance report run: {resp.status_code}\")\n            print(\"\\n--- Compliance Report Output ---\\n\")\n            print(resp.text)\n        else:\n            logging.error(f\"[POST] Failed to run compliance report: {resp.status_code}\\n{resp.text}\")\n            sys.exit(1)\n        return resp\n    except requests.RequestException as e:\n        logging.error(f\"[POST] Exception: {e}\")\n        sys.exit(1)\n\ndef parse_args():\n    parser = argparse.ArgumentParser(description='NSO Compliance Report Utility')\n    parser.add_argument('--nso_url', type=str, default=os.environ.get('NSO_DEV_IP', 'http://localhost:8080'), help='NSO server URL (e.g. http://10.10.20.47:8080)')\n    parser.add_argument('--username', type=str, default=os.environ.get('NSO_DEV_USER', 'developer'), help='NSO username')\n    parser.add_argument('--password', type=str, default=os.environ.get('NSO_DEV_PWD', 'C1sco12345'), help='NSO password')\n    parser.add_argument('--device', type=str, default='dev-dist-rtr01', help='Device name for compliance check')\n    parser.add_argument('--report_name', type=str, default='Loopback_report', help='Compliance report name')\n    parser.add_argument('--outformat', type=str, default='html', help='Output format for compliance report')\n    return parser.parse_args()\n\nif __name__ == \"__main__\":\n    args = parse_args()\n    logging.info(\"Starting NSO Compliance Report Utility...\")\n    create_compliance_report(\n        nso_url=args.nso_url,\n        user=args.username,\n        pwd=args.password,\n        device=args.device,\n        report_name=args.report_name\n    )\n    run_compliance_report(\n        nso_url=args.nso_url,\n        user=args.username,\n        pwd=args.password,\n        report_name=args.report_name,\n        outformat=args.outformat\n    )\n    logging.info(\"Compliance report process completed.\")\n</code></pre> <p>Add the following line to your <code>.gitlab-ci.yml</code> file to run the compliance check after applying the service:</p> <pre><code>- python nso_cicd/compliance.py --nso_url \"http://$NSO_DEV_IP:8080\" --username $NSO_DEV_USER --password $NSO_DEV_PWD\n</code></pre> <p>Commit your changes. Congratulations\u2014you've completed the workshop!</p>"},{"location":"lab_guides/testing/pre_checks/","title":"Pre-commit Checks","text":"<p>There are many types of testing we can perform within our pipelines, in this section we're going to add some basic xml linting to catch any unwanted typos, check connectivity to our devices and perform a config backup. The actual function isn't too important here, more to make it clear the functions of the different tools and their associated benefits and drawbacks.</p> <p>Reminder: What are some common testing types?</p> <p>Semantic Testing</p> <ul> <li>Semantic testing ensures that the network configurations and automation scripts achieve the intended network behavior and meet design specifications. This involves validating that the IaC scripts correctly configure network elements like routers, switches, and firewalls to deliver expected outcomes, such as correct routing, security policies, and connectivity. Example: Using NSO Compliance Reporting to check our services are correctly applied and our devices are in sync. </li> </ul> <p>Syntactical Testing</p> <ul> <li>Syntactical testing ensures that configuration scripts and templates conform to the syntax rules of the tools and avoid syntax errors such as incorrect indentation in YAML files or missing parameters in command-line interfaces. Example: Using xmllint to make sure our template xml's are free from typos.</li> </ul> <p>Environmental Testing - (Out of scope of this workshop)</p> <ul> <li>Environmental testing verifies that the network configurations work correctly across different network environments and hardware platforms. Simulations or staging environments that mimic production are used to test configurations under various conditions, such as different network topologies, device models, and firmware versions. Example: Testing a deployment in a lab environment that replicates the production setup to ensure it will perform correctly when deployed live.</li> </ul>"},{"location":"lab_guides/testing/pre_checks/#task-6-add-linting-to-pipeline","title":"Task 6: Add linting to pipeline","text":"Reminder:* What is xmllint <p>xmllint is a command-line XML tool used for parsing and validating XML documents, ensuring they are well-formed and adhere to their associated XML Schema Definition (XSD) or Document Type Definition (DTD). It also offers capabilities for formatting, querying, and extracting data from XML files, making it a versatile utility for XML manipulation and debugging.</p> <p>Pre-commits are a handy feature where we can test aspects of our code before the commit is executed. We use this for adding sshpass to the runner as an additional tool to the standard build. The code below performs a syntax check of our loopback template without any output upon success. Add it to our existing .pre stage or create a new job to execute the command.  <pre><code>- xmllint --noout nso_cicd/packages/loopback/templates/loopback-template.xml\n</code></pre></p>"},{"location":"lab_guides/testing/pre_checks/#task-7-create-a-robot-framework-test","title":"Task 7: Create a Robot Framework test","text":"<p>Robot Framework is an open-source automation framework designed for acceptance testing and robotic process automation (RPA). It uses a keyword-driven approach to create readable and reusable test cases and supports various external libraries for testing different types of applications and systems. We're going to use it to run some show commands and perform a config backup. </p> <p>Create a robot file in the <code>`nso_cicd/</code> folder named <code>pre_check.robot</code> using the code provided below:</p> <p><pre><code>*** Settings ***\nDocumentation          This example demonstrates executing a command on multiple remote machines\n...                    and getting their output.\n...                    It also demonstrates saving the backup of multiple network devices.\n\nLibrary                SSHLibrary\nLibrary                OperatingSystem   \nSuite Setup            Open Connections And Log In\nSuite Teardown         Close All Connections\n\n*** Variables ***\n@{ROUTER_IPS}    10.10.20.177    10.10.20.178\n${USERNAME}      cisco\n${PASSWORD}      cisco\n${COMMAND}       show ip interface brief\n${BACKUP_DIR}    $PWD/backups\n\n*** Test Cases ***\nSSH Into Routers And Execute Command\n    [Documentation]    Example test case to SSH into multiple routers and execute a command\n    FOR    ${ROUTER_IP}    IN    @{ROUTER_IPS}\n        ${output}=    Execute Command    ${COMMAND}\n        Log    ${output}\n    END\n\nNetwork Configuration Backup\n    [Documentation]  This test logs into multiple network devices, retrieves the configuration, and saves it to a file.\n    [Tags]  complex\n    ${BACKUP_DIR}=  Get Environment Variable  PWD\n    ${BACKUP_DIR}=  Set Variable  ${BACKUP_DIR}/backups\n    FOR    ${ROUTER_IP}    IN    @{ROUTER_IPS}\n        ${config}  Execute Command  show running-config\n        ${timestamp}  Get Time  epoch\n        ${backup_file}  Set Variable  ${BACKUP_DIR}/config_${ROUTER_IP}_${timestamp}.txt\n        Create File  ${backup_file}  ${config}\n        OperatingSystem.File Should Exist  ${backup_file}\n    END\n\n*** Keywords ***\nOpen Connections And Log In\n    FOR    ${ROUTER_IP}    IN    @{ROUTER_IPS}\n        Open Connection     ${ROUTER_IP}\n        Login               ${USERNAME}    ${PASSWORD}\n    END\n</code></pre> Now let's add this to our pipeline. Add the following code to the <code>.pre</code> stage of your <code>.gitlab-ci.yml</code> file:</p> <pre><code>- python -m robot nso_cicd/pre_check.robot\n</code></pre> <p>What was the outcome of the .pre stage.?</p>"}]}